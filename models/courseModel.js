const mongoose = require('mongoose');
const cryptoRandomString = require('crypto-random-string');
// const User = require("./userModel");

const courseSchema = new mongoose.Schema(
	{
		title: {
			type: String,
			minlength: 2,
			maxlength: 100,
			required: [true, 'Please Enter Course Title'],
		},
		description: {
			type: String,
		},
		instructor: {
			type: mongoose.Schema.ObjectId,
			ref: 'User',
		},
		students: [
			{
				type: mongoose.Schema.ObjectId,
				ref: 'User',
			},
		],
		createdAt: {
			type: Date,
			required: true,
			default: Date.now(),
		},
		active: {
			type: Boolean,
			default: true,
		},
		classCode: {
			type: String,
			unique: true,
		},
	},
	{
		toJSON: { virtuals: true },
		toObject: { virtuals: true },
	}
);
courseSchema.virtual('assignments', {
	ref: 'Assignment',
	foreignField: 'courseId',
	localField: '_id',
});
courseSchema.virtual('meetings', {
	ref: 'Meeting',
	foreignField: 'courseId',
	localField: '_id',
});
courseSchema.virtual('courseFiles', {
	ref: 'CourseMaterial',
	foreignField: 'courseId',
	localField: '_id',
});
courseSchema.pre(/^find/, function (next) {
	this.find({ active: true }).populate('courseFiles');
	next();
});
// Generating, Checking & Adding ClassCode Field
courseSchema.pre('save', async function (next) {
	let code;
	// Checking For Any Same OR Existing ClassCode
	do {
		code = cryptoRandomString({ length: 10, characters: this._id.toString() });
		// One More Condition Need To Be Solve. Condition: Maximum Limit
	} while (await Course.findOne({ classCode: code }));

	// Add Unique Autogenerated ClassCode
	this.classCode = code;
	next();
});

courseSchema.index({ classCode: 1 });

const Course = mongoose.model('Course', courseSchema);

Course.ensureIndexes(async function (err) {
	if (err) {
		return await err;
	}
});

// Course.on("index", (error) => {
//   if (error) {
//     console.error(error.message);
//   }
// });

module.exports = Course;
